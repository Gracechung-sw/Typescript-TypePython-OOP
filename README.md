# typescript-typepython-oop
# 객체지향의 사실과 오해 정리
## Chapter 2. 이상한 나라의 객체
객체지향 패러다임을 인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼 소프트웨어 세계 역시 인간이 인지할 수 있는 다양한 ‘소프트웨어' 객체들이 모여 이뤄져있다는 믿음에서 출발한다. 

하지만 딱 여기까지. 

현실세계의 모방이라 하기엔 실행중인 객체지향 애플리케이션의 내부는 전혀 다르다. 

현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 뭘까?
그것은 현실 속에서는 수동적인 존재가 SW객체로 구현될 때는 능동적으로 변한다는 것이다. 
따라서 모방이 아니라 이런 앞의 두줄에서 말한 생각을 기반으로 새로운 세계를 창조하는 것이라고 이해하는게 받아들이기 용이하다. 

저자는 이 새로운 세계를 <이상한 나라의 앨리스>의 세계에 비유해서 설명한다. 

### 1. 앨리스 객체 
- 상태: 특정 시점에서의 앨리스의 키
- 행동: 케이크 먹기.. 등
이 행동들에 의해서 상태가 바뀜
앨리스 객체의 특징을 살펴보면 
1. 앨리스는 상태를 가지며, 상태는 변경가능하다. 또한 행동의 결과는 상태에 의존적이다. 
2. 앨리스의 상태를 변경시키는 건 앨리스의 행동이다.   
  a. 행동의 결과는 상태에 의존적이다.  
  b. 행동의 순서가 결과에 영향을 미친다. 
3. 앨리스는 상태가 변하더라도 앨리스다. 즉, 상태의 변경과 무관하게 유일한 존재로 식별가능하다.   

이 1~3의 특징들을 SW객체로 가져와보면, 
1. 객체는 식별가능한 개체이다. 
2. 변경가능한 **상태/행동/식별자**를 가진다. 

그리고 앞으로는 이 3가지 **상태/행동/식별자에 대해 각각 알아보자.**   

### 2. 상태
#### 1) 상태가 필요한 이유   
‘뭔가를 하는 행동'은 과거의 행동의 결과에 의존적이다. 그럼 맨처음부터 지금까지 하려는 행동까지 어떤 행동을 해왔는가를 다 기억해야하나? 너무 비효율적이다. 조금만 생각해보면
행동의 결과인 상태만 기억하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다는 것을 알 수 있다. 바로 이러한 점 때문에 상태가 필요하다. 

#### 2) 상태를 어떻게 표현할 것인가
상태는 단순한 값과 객체의 조합으로 표현할 수 있다. 이 값과 객체들을 property라고 한다. 
이 단순값을 attribute라고 하고, 다른 객체를 가리키는 것은 link라고 한다. 


### 3. 행동
#### 1) 행동이 필요한 이유
객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 자발적인 행동 뿐이다. 반대로 말하면 외부에 의해 상태가 변경되는 것은 자율성 위반인 것이다. 
다시말해, 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다. 

#### 2) 객체 설계시 초점을 행동에 맞추라

이 객체 설계에 대한 것은 책을 읽어나가면서 계속해서 나오고, 배워가는 부분이다. 그런데 상태와 행동의 개념이 나오면부터 강조하는 것은 ‘객체 설계시 초점을 행동에 맞추라’는 것이다. 
왜 그래야 하는가? 객체는 다른 객체와 협력하기 위해 존재한다. 따라서 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다. 

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 미친다. 이유는
1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다. 
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다. 불행하게도 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다. 
3. 객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞춤 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하될 수밖에 없다.

이게 더 나아가면 ‘책임 주도 설계'까지 이어지며 이는 앞서 말한 것 처럼 앞으로 계속 배워나갈 주제 중 하나이다. 

### 4. 협력
객체는 다른 객체와 협력하기 위해 존재한다. 따라서 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이라고 했다. 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청을 보내는 것이다. 그리고 그 요청을 수신한 객체는 요청을 처리하기위해 적절한 방법에 따라 행동한다. 

그리고 이 협력에 행동으로 메세지를 통해 참여하면서 다른 객체의 상태변경을 **유발할 수 있다.**

### 5. 상태 캡슐화
상태 변경을 ‘한다' 가 아니라 ‘유발할 수 있다.’ 인 이유가 뭘까

상태 캡슐화이다. 협력을 위한 메시지를 앨리스에게 전송하는 객체이건 음료에게 메시지를 전송하는 앨리스 객체이건 메시지 송신자는 메시지 수신자의 상태변경에 대해서는 전혀 알지 못한다. 
이것이 캡슐화가 의미하는 것이다. 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다. 

결론적으로 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다. 이것이 상태를 캡슐화해야 하는 이유다. 

### 6. 식별자
