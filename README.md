# typescript-typepython-oop
# 객체지향의 사실과 오해 정리
## Chapter 2. 이상한 나라의 객체
객체지향 패러다임을 인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼 소프트웨어 세계 역시 인간이 인지할 수 있는 다양한 ‘소프트웨어' 객체들이 모여 이뤄져있다는 믿음에서 출발한다. 

하지만 딱 여기까지. 

현실세계의 모방이라 하기엔 실행중인 객체지향 애플리케이션의 내부는 전혀 다르다. 

현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 뭘까?
그것은 현실 속에서는 수동적인 존재가 SW객체로 구현될 때는 능동적으로 변한다는 것이다. 
따라서 모방이 아니라 이런 앞의 두줄에서 말한 생각을 기반으로 새로운 세계를 창조하는 것이라고 이해하는게 받아들이기 용이하다. 

저자는 이 새로운 세계를 <이상한 나라의 앨리스>의 세계에 비유해서 설명한다. 

### 1. 앨리스 객체 
- 상태: 특정 시점에서의 앨리스의 키
- 행동: 케이크 먹기.. 등
이 행동들에 의해서 상태가 바뀜
앨리스 객체의 특징을 살펴보면 
1. 앨리스는 상태를 가지며, 상태는 변경가능하다. 또한 행동의 결과는 상태에 의존적이다. 
2. 앨리스의 상태를 변경시키는 건 앨리스의 행동이다.   
  a. 행동의 결과는 상태에 의존적이다.  
  b. 행동의 순서가 결과에 영향을 미친다. 
3. 앨리스는 상태가 변하더라도 앨리스다. 즉, 상태의 변경과 무관하게 유일한 존재로 식별가능하다.   

이 1~3의 특징들을 SW객체로 가져와보면, 
1. 객체는 식별가능한 개체이다. 
2. 변경가능한 **상태/행동/식별자**를 가진다. 

그리고 앞으로는 이 3가지 **상태/행동/식별자에 대해 각각 알아보자.**   

### 2. 상태
#### 1) 상태가 필요한 이유   
‘뭔가를 하는 행동'은 과거의 행동의 결과에 의존적이다. 그럼 맨처음부터 지금까지 하려는 행동까지 어떤 행동을 해왔는가를 다 기억해야하나? 너무 비효율적이다. 조금만 생각해보면
행동의 결과인 상태만 기억하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다는 것을 알 수 있다. 바로 이러한 점 때문에 상태가 필요하다. 

#### 2) 상태를 어떻게 표현할 것인가
상태는 단순한 값과 객체의 조합으로 표현할 수 있다. 이 값과 객체들을 property라고 한다. 
이 단순값을 attribute라고 하고, 다른 객체를 가리키는 것은 link라고 한다. 


### 3. 행동
#### 1) 행동이 필요한 이유
객체의 상태는 저절로 변경되지 않는다. 객체의 상태를 변경하는 것은 객체의 자발적인 행동 뿐이다. 반대로 말하면 외부에 의해 상태가 변경되는 것은 자율성 위반인 것이다. 
다시말해, 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다. 

#### 2) 객체 설계시 초점을 행동에 맞추라

이 객체 설계에 대한 것은 책을 읽어나가면서 계속해서 나오고, 배워가는 부분이다. 그런데 상태와 행동의 개념이 나오면부터 강조하는 것은 ‘객체 설계시 초점을 행동에 맞추라’는 것이다. 
왜 그래야 하는가? 객체는 다른 객체와 협력하기 위해 존재한다. 따라서 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이다. 

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 미친다. 이유는
1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다. 
2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다. 불행하게도 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다. 
3. 객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞춤 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하될 수밖에 없다.

이게 더 나아가면 ‘책임 주도 설계'까지 이어지며 이는 앞서 말한 것 처럼 앞으로 계속 배워나갈 주제 중 하나이다. 

### 4. 협력
객체는 다른 객체와 협력하기 위해 존재한다. 따라서 객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동이라고 했다. 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청을 보내는 것이다. 그리고 그 요청을 수신한 객체는 요청을 처리하기위해 적절한 방법에 따라 행동한다. 

그리고 이 협력에 행동으로 메세지를 통해 참여하면서 다른 객체의 상태변경을 **유발할 수 있다.**

### 5. 상태 캡슐화
상태 변경을 ‘한다' 가 아니라 ‘유발할 수 있다.’ 인 이유가 뭘까

상태 캡슐화이다. 협력을 위한 메시지를 앨리스에게 전송하는 객체이건 음료에게 메시지를 전송하는 앨리스 객체이건 메시지 송신자는 메시지 수신자의 상태변경에 대해서는 전혀 알지 못한다. 
이것이 캡슐화가 의미하는 것이다. 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다. 

결론적으로 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다. 이것이 상태를 캡슐화해야 하는 이유다. 

### 6. 식별자

## Chapter 3. 객체지향과 추상화(의 관계)
트럼프와 토끼로 나눈건, 앨리스가 인물들의 차이점을 의도적으로 무시하고 공통점만을 강조함으로써 트럼프라는 개념으로 단순화, 분류했는데 이게 추상화의 일종이다. 

분류는 객체지향의 가장 중요한 개념 중의 하나다. 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다. 

이 개념에는 3가지 관점이 있고, 이 3가지 관점이 만족 될 때 각 객체는 그 개념의 일원이 된다. 
1. symbol
2. 내연
3. 외연

### 1. 타입
컴퓨터 공학자에게 앞서 살펴본 ‘개념'의 용어를 대체하는 것이 바로 ‘타입'이다. 
타입에는 
1. 데이터 타입
2. 객체지향의 타입
이 있다. 

#### 1) 데이터 타입
컴퓨터가 어떤 작업을 수행하기 위해서는 작업에 필요한 데이터를 메모리 안으로 불러들여야 한다. 메모리에 불러들여진 데이터들은 무수히 많은 0과 1로 치장되어 저장된다. 
사람들은 이 메모리 안의 데이터에 특정한 의미를 부여해서 논리형으로 분류했다. 
<details>
<summary>변수</summary>

# Variable

## 변수란 무엇인가? 왜 필요한가?

### 메모리와 변수가 필요한 이유, 배경
사람은 계산과 기억을 모두 두뇌에서 파지만, 컴퓨터는 연산과 기억을 수행하는 부품이 나눠져 있다. 컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.   

메모리상에 데이터를 읽고 쓰고   
메모리는 데이터를 저장할 수 있는 메모리 cell의 집합체   
메모리 cell = 1 byte(8 bit) size

applicatio이 메모리상에 올라왔을 때,
이 메모리는
- Code
- Data
- Stack
- Heap
  의 메모리 구조를 가진다.


Application이 실행되면

- 입력(input) -> 처리(process) -> 출력(output)/저장(storage) 큰 3가지 줄기를 가진다.
- 이 중 처리(process)에서 처리 과정 중의 데이터(ex. 사용자에게 입력받은 데이터라던지..)를 잠시 저정해 두는 것이 필요.

10 + 20 이라는 연산에서 연산 결과 30을 재사용하고 싶다면 메모리 주소를 통해 연산 결과인 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다. 하지만!
- 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 가능성이 높은 매우 위험한 일이다. 
- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
 
### 그래서 변수란?
프로그래밍 언어느 ㄴ기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어들여 재사용하기 위해 변수를 사용한다. 따라서 
변수(Variable)은

- 값을 저장하기 위해 확보한 메모리 공간
- 그리고 그 메모리 공간을 식별하기 쉽도록 **이름이 주어진** 기억장소
- 값의 위치를 가리키는 상징적인 이름.

그리고 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다.   
자바스크립트의 경우는 자바스크립트 엔진이 변수명과 **매핑**된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다. 

```
let result = 10 + 20
```
에서 변수(식별자에 속한다)result는 값 30이 저장되어 있는 메모리 주소 0x066..어쩌고 를 기억해야한다. 
즉, 변수는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.   

변수명 result --> 메모리 주소 0x066..어쩌고 -- 메모리 30
</details>


즉 데이터를 목록에 따라 분류하기 시작하면서 타입 시스템이 자라나기 시작했다. 
<details>
<summary>데이터 타입(JS, Python)</summary>


## Data Type
### JS
JavaScript type is dynamic, weakly typed programming language
```JS
/**
 * Data Type
 */
console.log(0 / 123); // 0
console.log(123 / 0); // Infinity
console.log(123 / -0); // -Infinity
console.log(123 / 'text'); // NaN (Not a Number)

let bigInt = 1234565677843523426133451243513461561432525125n; // bitInt는 뒤에 n을 붙이면 bigint type으로 다룰 수 있다.
console.log(bigInt);

console.clear();
// Falshy 인 값
console.log(!!0);
console.log(!!-0);
console.log(!!''); // 빈 문자열
console.log(!!null);
console.log(!!undefined);
console.log(!!NaN);
// Truthy 인 값
console.log(!!1);
console.log(!!-1);
console.log(!!'text'); // 비어있지 않은 문자열
console.log(!!{});
console.log(!!Infinity);
```

### primitive type(원시, 단일 데이터 타입)

- number

  - MDN BigInt(2^53-1): https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt

  - MDN Number: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number

- string
- boolean
- null : 텅텅 비어있는 것을 말함
- undefined
- Symbol

**원시 타입은 어디에 변수가 선언되어 있느냐에 따라 Memory(local variable)의 Data(global variable)나 Stack memory에 값이 위치해있다.**

### Object(복합 데이터- 원시, 단일 데이터 타입이 아닌 모든 타입)

- object

  - array
  - function
  - ...

  object는 야러 데이터의 상태, 행동을 함께 묶어서 보관할 수 있는 데이터 타입을 복합 데이터, 객체. 라고 한다.`{key: value}` 로 표현 가능.

  **object는 어떤 데이터든 복합적으로 들어있을 수 있기 때문에 크기가 정해져있지 않다. 그래서 메모리 사이즈가 정해져있지 않고, 동적으로 조절가능한 Memory Heap에 여러 cell에 걸쳐서 데이터가 보관된다.**
  참고) 정확한 이해를 위해서는 그림이 좋다. 그림1
</details>

이게 전통적인 데이터 타입에서의 ‘타입'이고, 객체 지향의 ‘타입'과는 아래와 같은 연관성이 있다. 

#### 2) 객체지향의 타입
객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다. 앞에서 데이터 타입에 관해 언급했던 두 가지 조언은 객체의 타입을 이야기할 때도 동일하게 적용된다. 
a. 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 **행동**이다. 
b. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 

### 2. 타입의 목적
왜 타입을 사용해야 하는가?    
객체지향은 객체를 지향하는 것이므로 객체만 다루면 되지 않냐고 생각 할 수 도 있지만 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.    
타입은 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다.   
앨리스의 상태에 복잡성을 부과하는 시간이라는 요소를 제거함으로써 시간에 독립적인 정적인 모습으로 앨리스를 생각할 수 있게 해준다. 

### 3. 결국 타입은 추상화다. 
타입은 추상화다 **타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다.** 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다. 

> - TS abstract class: see https://github.com/Gracechung-sw/typescript-typepython-oop/blob/main/oop/abstract.ts
> - Python abstract class: see 



### 4. 객체를 생각할 때 고려해야할 동적 모델과 정적 모델
#### 1) 동적 모델
객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐를 스냅샷, 객체 다이어그램이라고 하고, 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지 를 포착하는 것을 동적 모델이라고 한다. 

#### 2) 정적 모델
객체가 가질 수 있는 모든 상태와 모든 행도을 시간에 독립적으로 표현하는 것은 타입 모델이라고 하고 이 모델은 객체가 속한 타입의 정적인 모습을 표현하기 때문에 정적 모델이라고도 한다. 


### 5.객체지향 설계에 대한 중요한 원칙
타입의 특징을 고려하면 객체지향 설계에 대한 중요한 원칙을 이끌어 낼 수 있다. 
#### 1) 행동이 우선이다. 
어떤 객체를 다른 객체와 동일한 타입으로 분류하는 길은 무엇인가? 그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 
결론적으로 객체의 타입을 결정하는 것은 객체의 행동 뿐이다. 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는데 마루언 영향도 미치지 않는다. 
이러한 이유로, 타입이 데이터가 아닌 행동에 의해 결정된다는 사실은 객체지향 패러다임을 특징 짓는 중요한 몇 가지 우너리와 원칙에 의미를 부여한다. 

같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 여기서 **동일한 행동 =  동일한 책임 = 동일한 메시지 수신**

따라서 동일한 타입에 속한 객체는 내부의 데티터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수 밖에 없다. **(다형성 Polymorphism)**

그리고 캡슐화로 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. 

**책임-주도 설계**라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 데이터-주도 설계 방법의 단점을 개선하기 위해 고안됐다. 

#### 2) 일반화와 특수화
객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다. 어떤 객체가 다른 객체보다 더 일반적인 상태를 표현하거나 더 특수한 상태를 표현한다고 해서 두 객체가 속하는 타입 간에 일반화/특수화 관계가 성립하는 것은 아니다. 그렇다고 생각이 드는게, 다형성으로 데이터, 상태는 각 객체마다 다를 수 있다는 것을 앞에서 살펴봤기 때문이다.    
일반화/특수화는 행동에 관한 것이고 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다. 

#### 3) 슈퍼 타입과 서브 타입
일반화/특수화 관계는 좀 더 이란적인 한 타입과 좀 더 특수한 한 타입 간의 관계다. 이 때 좀 더 일반적인 타입을 슈퍼타입, 좀 더 특수한 타입을 서브타입이라고 한다. 
특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 한다. 

결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 ‘상태'와 상태를 변경하는 ‘행위'이다. 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘일 뿐이다. 

